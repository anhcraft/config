package dev.anhcraft.config;

import dev.anhcraft.config.adapter.TypeAdapter;
import dev.anhcraft.config.adapter.TypeInferencer;
import dev.anhcraft.config.blueprint.*;
import dev.anhcraft.config.context.Context;
import dev.anhcraft.config.context.ElementScope;
import dev.anhcraft.config.context.PropertyScope;
import dev.anhcraft.config.context.ValueScope;
import dev.anhcraft.config.error.IllegalTypeException;
import dev.anhcraft.config.error.InvalidValueException;
import dev.anhcraft.config.meta.Denormalizer;
import dev.anhcraft.config.meta.Fallback;
import dev.anhcraft.config.type.ComplexTypes;
import dev.anhcraft.config.type.SimpleTypes;
import dev.anhcraft.config.type.TypeResolver;
import dev.anhcraft.config.type.TypeToken;
import java.lang.reflect.Array;
import java.lang.reflect.Type;
import java.util.*;
import org.jetbrains.annotations.ApiStatus;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

/**
 * The denormalizer complexifies a simple object with the following rules:
 * <ul>
 *     <li>Primitive and String are transformed using the built-in type adapters (*)</li>
 *     <li>Array is recursively checked with each element denormalized independently</li>
 *     <li>Dictionary is denormalized into a new instance of the target type</li>
 * </ul>
 * The denormalizer may return {@code null} even if the target type is primitive.<br>
 * Developers may use {@link TypeAdapter} to have further fine-grained control over the denormalization process. If such
 * adapter is not found, the denormalizer tries to denormalize the object using the schema generated by the current
 * {@link ConfigFactory} with the prerequisite is that the source setting must be a dictionary. Failing to denormalize
 * an object will result in {@code null} or implicit skip.<br>
 * When denormalizing a dictionary without type adapter into an instance of a parameterized type, it is important to
 * provide fully-informed actual type using {@link TypeToken} so that parameterized types of fields can be resolved
 * recursively, which results in a complete denormalization.<br>
 * It is possible to hide certain data by specifying the superclass as the target type. This results in implicit
 * creation of the schema of the superclass. The result hides the details of the actual class and only contains the
 * information from the superclass up to the root of class hierarchy.
 * @see TypeAdapter
 * @see TypeToken
 */
public class ConfigDenormalizer {
  private final ConfigFactory configFactory;
  private final Set<SettingFlag.Denormalizer> settings;

  /**
   * Use {@link ConfigFactory#getDenormalizer()}
   */
  @ApiStatus.Internal
  public ConfigDenormalizer(ConfigFactory configFactory, Set<SettingFlag.Denormalizer> settings) {
    this.configFactory = configFactory;
    this.settings = Collections.unmodifiableSet(settings);
  }

  private Context createContext() {
    return configFactory.getContextProvider().provideDenormalizationContext(configFactory);
  }

  /**
   * Gets the setting flags.
   * @return the settings
   */
  public @NotNull Set<SettingFlag.Denormalizer> getSettings() {
    return settings;
  }

  /**
   * Denormalizes the given simple object into a complex object.<br>
   * This creates a new {@link Context} to facilitate recursive calls.
   * @param simple the simple object
   * @param targetType the target complex type
   * @return the complex object or {@code null} if the object cannot be denormalized
   * @param <T> the type of the simple object
   * @throws Exception may throw exceptions during denormalization
   * @see #denormalize(Context, Object, Type)
   */
  public <T> @Nullable Object denormalize(@Nullable T simple, @NotNull Type targetType)
      throws Exception {
    return denormalize(createContext(), simple, targetType);
  }

  /**
   * Denormalizes the given simple object into a complex object.
   * @param ctx the {@link Context} to use
   * @param simple the simple object
   * @param targetType the target complex type
   * @return the complex object or {@code null} if the object cannot be denormalized
   * @param <T> the type of the simple object
   * @throws Exception may throw exceptions during denormalization
   */
  public <T> @Nullable Object denormalize(
      @NotNull Context ctx, @Nullable T simple, @NotNull Type targetType) throws Exception {
    validateSimpleType(ctx, simple);
    return _denormalize(ctx, simple, targetType);
  }

  /**
   * Denormalizes the given dictionary into the given instance.<br>
   * This creates a new {@link Context} to facilitate recursive calls.
   * @param simple the dictionary
   * @param targetType the target complex type
   * @param instance the instance
   * @throws Exception may throw exceptions during denormalization
   */
  public void denormalizeToInstance(
      @NotNull Dictionary simple, @NotNull Type targetType, @NotNull Object instance)
      throws Exception {
    denormalizeToInstance(createContext(), simple, targetType, instance);
  }

  /**
   * Denormalizes the given dictionary into the given instance.
   * @param ctx the {@link Context} to use
   * @param simple the dictionary
   * @param targetType the target complex type
   * @param instance the instance
   * @throws Exception may throw exceptions during denormalization
   */
  public void denormalizeToInstance(
      @NotNull Context ctx,
      @NotNull Dictionary simple,
      @NotNull Type targetType,
      @NotNull Object instance)
      throws Exception {
    validateSimpleType(ctx, simple);
    validateComplexType(ctx, instance, targetType);
    _denormalizeToInstance(ctx, simple, targetType, instance);
  }

  // ======== Internal implementations ========

  private <T> void validateSimpleType(Context ctx, T simple) {
    if (!SimpleTypes.test(simple))
      throw new IllegalTypeException(ctx, "Supplied argument is not a simple object: " + simple);
  }

  private void validateComplexType(
      Context ctx, @NotNull Object instance, @NotNull Type targetType) {
    try {
      Class<?> erasureType = ComplexTypes.erasure(targetType);
      if (!erasureType.isAssignableFrom(instance.getClass()))
        throw new IllegalTypeException(
            ctx, "Supplied instance is not compatible to " + erasureType.getName());
    } catch (ClassNotFoundException e) {
      throw new IllegalTypeException(ctx, "Cannot perform type check", e);
    }
  }

  @SuppressWarnings("rawtypes")
  private <T> Object _denormalize(Context ctx, @Nullable T simple, @NotNull Type targetType)
      throws Exception {
    if (simple == null) return null;
    if (targetType == Object.class) return simple;
    if (ComplexTypes.isArray(targetType)) return _denormalizeToArray(ctx, targetType, simple);
    Class<?> erasureType = ComplexTypes.erasure(targetType);
    TypeAdapter adapter = configFactory.getTypeAdapter(erasureType);
    if (adapter != null && !(adapter instanceof TypeInferencer)) {
      Object result = adapter.complexify(ctx, simple, targetType);
      if (result != null
          && !ComplexTypes.wrapPrimitive(erasureType).isAssignableFrom(result.getClass())) {
        String msg =
            String.format(
                "Adapter returned incompatible type '%s' while the desire is '%s'",
                result.getClass().getName(), erasureType.getName());
        throw new IllegalTypeException(ctx, msg);
      }
      return result;
    }
    if (!(simple instanceof Dictionary)) return null;
    Object object = configFactory.getInstanceFactory().newInstance(ctx, erasureType);
    _denormalizeToInstance(ctx, (Dictionary) simple, targetType, object);
    return object;
  }

  private <T> Object _denormalizeToArray(Context ctx, Type targetType, T simple) throws Exception {
    Type elemType = ComplexTypes.getComponentType(targetType);
    if (elemType == null) return null;
    Class<?> erasureElemType = ComplexTypes.erasure(elemType);
    int len = SimpleTypes.getContainerSize(simple);
    Object object = Array.newInstance(erasureElemType, len);
    for (int i = 0; i < len; i++) {
      ctx.enterScope(new ElementScope(i));
      {
        Object value = _denormalize(ctx, SimpleTypes.getContainerElement(simple, i), elemType);
        ctx.enterScope(new ValueScope(value));
        Array.set(object, i, value);
        ctx.exitScope();
      }
      ctx.exitScope();
    }
    return object;
  }

  private void _denormalizeToInstance(
      Context ctx, Dictionary simple, Type targetType, Object instance) throws Exception {
    TypeResolver resolver = TypeResolver.of(targetType);
    ClassSchema schema = configFactory.getSchema(ComplexTypes.erasure(targetType));
    Set<String> settingsProcessed = new HashSet<>();

    for (ClassProperty property : schema.properties()) {
      if (property.isConstant()) continue;

      String setting;
      Object value;

      // if there is a fallback property at the end, we collect all remaining settings including the
      // setting of the
      // fallback property
      if (property.isFallback()) {
        Fallback fallback = property.field().getAnnotation(Fallback.class);
        Set<String> exclusion;
        if (fallback.distinctBy() == Fallback.Distinct.NAME) {
          exclusion = settingsProcessed;
        } else {
          exclusion = new HashSet<>();
          for (String s : settingsProcessed) {
            ClassProperty cp = schema.property(s);
            if (cp != null) {
              exclusion.add(cp.name());
              exclusion.addAll(cp.aliases());
            }
          }
        }
        SchemalessDictionary trap = new SchemalessDictionary();
        for (Map.Entry<String, Object> entry : simple.entrySet()) {
          if (!exclusion.contains(entry.getKey())) trap.put(entry.getKey(), entry.getValue());
        }
        setting = "";
        value = trap;
      } else {
        Map.Entry<String, Object> entry = simple.search(property.name(), property.aliases());
        setting = entry == null ? "" : entry.getKey();
        value = entry == null ? null : entry.getValue();
      }

      ctx.enterScope(new PropertyScope(property, setting, simple));
      scope:
      {
        Processor processor = property.denormalizer();

        if (processor != null && processor.strategy() == Denormalizer.Strategy.REPLACE) {
          if (processor.invoker() instanceof Processor.VoidDenormalizationInvoker) {
            ((Processor.VoidDenormalizationInvoker) processor.invoker())
                .invoke(ctx, instance, value);
            break scope;
          }
          value =
              ((Processor.DenormalizationInvoker) processor.invoker()).invoke(ctx, instance, value);
        } else {
          if (value != null) {
            Type solvedType = resolver.resolve(property.type());
            value = _denormalize(ctx, value, solvedType);
          }

          if (processor != null && processor.strategy() == Denormalizer.Strategy.AFTER) {
            if (processor.invoker() instanceof Processor.VoidDenormalizationInvoker) {
              ((Processor.VoidDenormalizationInvoker) processor.invoker())
                  .invoke(ctx, instance, value);
              break scope;
            }
            value =
                ((Processor.DenormalizationInvoker) processor.invoker())
                    .invoke(ctx, instance, value);
          }
        }

        if (property.isOptional() && value == null) break scope;

        Class<?> propertyTypeErasure = ComplexTypes.erasure(property.type());

        if (value == null && propertyTypeErasure.isPrimitive()) break scope;

        if (value != null
            && !ComplexTypes.wrapPrimitive(propertyTypeErasure).isAssignableFrom(value.getClass()))
          break scope;

        if (!ctx.getFactory()
                .getDenormalizer()
                .getSettings()
                .contains(SettingFlag.Denormalizer.DISABLE_VALIDATION)
            && !property.validator().check(value)) {
          if (property.validator().silent()) break scope;
          throw new InvalidValueException(
              ctx, String.format("Property '%s' %s", property.name(), property.validator().message()));
        }

        ctx.enterScope(new ValueScope(value));
        property.field().set(instance, value);
        ctx.exitScope();
      }
      ctx.exitScope();

      settingsProcessed.add(setting);
    }
  }
}
