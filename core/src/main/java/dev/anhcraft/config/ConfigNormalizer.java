package dev.anhcraft.config;

import dev.anhcraft.config.adapter.AdapterContext;
import dev.anhcraft.config.adapter.TypeAdapter;
import dev.anhcraft.config.blueprint.Property;
import dev.anhcraft.config.blueprint.Schema;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

import java.lang.reflect.Array;

/**
 * The normalizer simplifies a complex object with the following rules:
 * <ul>
 *     <li>{@code null} is returned as is</li>
 *     <li>Primitive, primitive wrappers, String and {@link Wrapper} are returned as is</li>
 *     <li>Array is recursively checked with each element normalized independently</li>
 *     <li>Common reference types are normalized using the built-in type adapters</li>
 * </ul>
 * For the rest of reference types, Config tries to normalize it automatically using the schema generated by the
 * current {@link ConfigFactory}. Developers may use {@link TypeAdapter} to have further fine-grained control over
 * the normalization process. Failing to normalize an object will result in {@code null}.
 * It is possible to encapsulate the output by specifying the superclass as the target type. This results in implicit
 * creation of the schema of the superclass. The result hides the details of the actual class and only contains the
 * information since the superclass up to the root of class hierarchy.
 * @see SimpleTypes#validate(Object)
 * @see TypeAdapter
 */
public class ConfigNormalizer {
    private final ConfigFactory configFactory;
    private final int contextDepthLimit;

    public ConfigNormalizer(ConfigFactory configFactory, int contextDepthLimit) {
        this.configFactory = configFactory;
        this.contextDepthLimit = contextDepthLimit;
    }

    /**
     * Normalizes the given complex object into a simple object.<br>
     * This creates a new {@link AdapterContext} to facilitate recursive calls.
     * @param complex the complex object
     * @return the simple object or {@code null} if the object cannot be normalized
     * @param <T> the type of the simple object
     * @throws Exception may throw exceptions during normalization
     * @see #normalize(AdapterContext, Class, Object)
     */
    @Nullable
    public <T> Object normalize(@NotNull T complex) throws Exception {
        //noinspection unchecked
        return normalize(new AdapterContext(configFactory, 0), (Class<T>) complex.getClass(), complex);
    }

    /**
     * Normalizes the given complex object into a simple object.<br>
     * This creates a new {@link AdapterContext} to facilitate recursive calls.
     * @param type the class or superclass of the complex object
     * @param complex the complex object
     * @return the simple object or {@code null} if the object cannot be normalized
     * @param <S> the type or supertype of the complex object
     * @param <T> the type of the simple object
     * @throws Exception may throw exceptions during normalization
     * @see #normalize(AdapterContext, Class, Object)
     */
    @Nullable
    public <S, T extends S> Object normalize(@NotNull Class<S> type, @NotNull T complex) throws Exception {
        validateType(type, complex);
        return _normalize(new AdapterContext(configFactory, 0), type, complex);
    }

    /**
     * Normalizes the given complex object into a simple object.<br>
     * This normalizes {@code complex} using the schema of {@code type} and its superclasses. {@code <S>} can
     * be bounded to a certain supertype of {@code <T>} to make the simple object more generic. However, this
     * only works for the first layer of the transformation.
     * @param ctx the {@link AdapterContext} to use
     * @param type the class or superclass of the complex object
     * @param complex the complex object
     * @return the simple object or {@code null} if the object cannot be normalized
     * @param <S> the type or supertype of the complex object
     * @param <T> the type of the simple object
     * @throws Exception may throw exceptions during normalization
     */
    @Nullable
    public <S, T extends S> Object normalize(@NotNull AdapterContext ctx, @NotNull Class<S> type, @NotNull T complex) throws Exception {
        validateType(type, complex);
        return _normalize(ctx, type, complex);
    }

    private <S, T extends S> void validateType(Class<S> type, T complex) {
        if (!type.isAssignableFrom(complex.getClass()))
            throw new IllegalArgumentException("the given type is not the correct type or a supertype of the given complex object");
    }

    @SuppressWarnings({"rawtypes", "unchecked"}) // generic sucks
    private Object _normalize(AdapterContext ctx, Class<?> type, Object complex) throws Exception {
        if (SimpleTypes.validate(complex))
            return complex;
        if (type.isArray())
            return _normalizeArray(ctx, complex); // flat operation
        TypeAdapter adapter = configFactory.getTypeAdapter(type);
        if (adapter == null)
            return _dynamicNormalize(ctx, type, complex); // flat operation
        if (ctx.commitDepth() > contextDepthLimit) // prevent overflow due to bad type-adapting
            return null;
        Object v = adapter.simplify(ctx, type, complex);
        ctx.releaseDepth();
        return v;
    }

    private Object _normalizeArray(AdapterContext ctx, Object complex) throws Exception {
        int n = Array.getLength(complex);
        Object[] result = new Object[n];
        for (int i = 0; i < n; i++) {
            Object elem = Array.get(complex, i);
            Class<?> clazz = elem.getClass();
            result[i] = _normalize(ctx, clazz, elem);
        }
        return result;
    }

    private Wrapper _dynamicNormalize(AdapterContext ctx, Class<?> type, Object complex) throws Exception {
        Wrapper container = new Wrapper();
        Schema schema = ctx.getFactory().getSchema(type);
        for (Property property : schema.properties()) {
            if (property.isTransient())
                continue;
            Object value = property.field().get(complex);
            value = _normalize(ctx, value.getClass(), value);
            container.set(property.name(), value);
        }
        return container;
    }
}
